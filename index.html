<!DOCTYPE html>
<html>
    <head>
        <title>Test</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Bootstrap -->
        <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
        <script src="http://code.jquery.com/jquery.js"></script>
        <script src="bootstrap/js/bootstrap.min.js"></script>


        <!-- <script src="vexflow/build/vexflow/vexflow-min.js"></script> -->
        <!-- <script src="vexflow_test.js"></script> -->

        <script src="initialize_environment.js"></script>
        <script src="csp_solver.js"></script>
        <script src="create_matrix.js"></script>
        <script src="create_simple_constraint.js"></script>
        <script src="create_compound_constraint.js"></script>
        <script src="default_constraints.js"></script>

    </head>
    <body>

	<script type="text/javascript">

        function display_results_in_log(results){
            for(var i = results[0].length -1; i > -1; i--){
                var melodic_line = "";
                for(var j = 0; j < results.length; j++){
                    var note = results[j][i];
                    if(note < 10){
                        melodic_line += note + "   ";
                    }else if(note < 100){
                        melodic_line += note + " ";
                    }else{
                        melodic_line += note + "  ";
                    }
                }
                console.log(melodic_line);
            }
        }
        function make_voice(ln,hn,vc,u){
            return {
                low_note:ln,
                high_note:hn,
                voice_crossing:vc,
                unison:u
            };
        }
        function make_chord_list(){
            this.I=[0,4,7];
            this.IV=[5,9,0];
            this.V=[7,11,2];
        }

 
        //intialize environment   
        var env = initialize_environment();
        env['length'] = 4;
        env['chord_progression'] = ["I","IV","V","I"];
 
        //set up voicing rules 
        var voicing_rules = [make_voice(30,49,false,true),
                             make_voice(42,61,false,true),
                             make_voice(54,73,false,true),
                             make_voice(66,85,false,true)];
    
        //set chord progression
        chord_progression = ["I","IV","V","I"];
        var chord_list = {I:[0,4,7],IV:[5,9,0],V:[7,11,2]};

        //create matrix to solve 
        env['matrix'] = create_matrix(voicing_rules,chord_progression,chord_list);

        //apply constraints to matrix
        apply_default_constraint(env,parallel_intervals("parallel_fifths",[6,7],2));
        apply_default_constraint(env,parallel_intervals("parallel_octaves",[12],2));
        apply_default_constraint(env,max_distance([12]));
        apply_default_constraint(env,min_distance([1]));
        apply_default_constraint(env,upward_leap_recovery());
        apply_default_constraint(env,downward_leap_recovery());


        //solve matrix
        var results = evaluate_matrix(env);   
    
        display_results_in_log(results);
 








/*

        //create leap up recovery constraint
 		
        //checks for a leap up of a fifth or greater
        var options = {};
        options['eval_function'] = 
            function(interval,intervals,options){ 

                if(interval == undefined)
                    return false;
                
                var result = false;
                for(var i = 0; i < intervals.length; i++){
                    if(interval >= intervals[i])
                        result = true;
                    }
                return result;
            };

		create_simple_constraint(env,"leap_up",[7],options);
	    

        //check for a leap down of a fourth or greater
        var options = {};
        options['eval_function'] = 
            function(interval,intervals,options){ 

                if(interval == undefined)
                    return false;
                
                var result = false;
                for(var i = 0; i < intervals.length; i++){
                    if(interval <= intervals[i] || interval >= 0)
                        result = true;
                    }
                return result;
            };

		create_simple_constraint(env,"recover_down",[-4],options);
	

        //create compound constraint of upward leap recovery
        var cc_options = {};
        cc_options['rule_type'] = false;
        var overall_context = {};
        overall_context['properties'] = {};
        overall_context['comparison_functions'] = {};

		create_compound_constraint(env,"upward_leap_recovery",
                                   ["leap_up","recover_down"],cc_options);	
 
        overall_context['properties']['length'] = 3;
        overall_context['comparison_functions']['length'] = 
            function(env,i,env_property,context_property){
                if(i+(context_property)-1 < env_property)
                    return true;
                else
                    return false; 
            };

        console.log("upward leap recovery");
        var compound_constraint = compound_constraint_lookup_by_name['upward_leap_recovery'];
        apply_constraint_horizontally(overall_context, compound_constraint,3);      
     





   
           

        //downward leap recovery constraint
        
        //checks for a leap up of a fifth or greater
        var options = {};
        options['eval_function'] = 
            function(interval,intervals,options){ 

                if(interval == undefined)
                    return false;
                
                var result = false;
                for(var i = 0; i < intervals.length; i++){
                    if(interval <= intervals[i])
                        result = true;
                    }
                return result;
            };

		create_simple_constraint(env,"leap_down",[-7],options);

        //check for a leap down of a fourth or greater
        var options = {};
        options['eval_function'] = 
            function(interval,intervals,options){ 

                if(interval == undefined)
                    return false;
                
                var result = false;
                for(var i = 0; i < intervals.length; i++){
                    if(interval > intervals[i] || interval <= 0 )
                        result = true;
                    }
                return result;
            };

		create_simple_constraint(env,"recover_up",[4],options);
	

        //create compound constraint of upward leap recovery
        var cc_options = {};
        cc_options['rule_type'] = false;
        var overall_context = {};
        overall_context['properties'] = {};
        overall_context['comparison_functions'] = {};

		create_compound_constraint(env,"downward_leap_recovery",
                                   ["leap_down","recover_up"],cc_options);	
 
        overall_context['properties']['length'] = 3;
        overall_context['comparison_functions']['length'] = 
            function(env,i,env_property,context_property){
                if(i+(context_property)-1 < env_property)
                    return true;
                else
                    return false; 
            };

        console.log("downward leap recovery");
        var compound_constraint = compound_constraint_lookup_by_name['downward_leap_recovery'];
        apply_constraint_horizontally(overall_context, compound_constraint,3);      
  */      










 
  
	</script>

    </body>
</html>
